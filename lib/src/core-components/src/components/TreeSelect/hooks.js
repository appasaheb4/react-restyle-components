"use strict";import{useState as x,useCallback as g,useEffect as L}from"react";export function getFieldValue(o,t,e={}){const n={label:e.label||"title",value:e.value||"value",children:e.children||"children"};return o[n[t]]}export function flattenTree(o,t,e){const n=[];for(const c of o){const r=getFieldValue(c,"value",t),a=getFieldValue(c,"children",t),f=e?[...e.path,r]:[r];n.push({...c,parent:e,path:f}),a&&Array.isArray(a)&&n.push(...flattenTree(a,t,{...c,path:f}))}return n}export function findNodeByValue(o,t,e){for(const n of o){const c=getFieldValue(n,"value",e),r=getFieldValue(n,"children",e);if(c===t)return n;if(r&&Array.isArray(r)){const a=findNodeByValue(r,t,e);if(a)return a}}}export function getDescendantValues(o,t){const e=[],n=getFieldValue(o,"children",t);if(n&&Array.isArray(n))for(const c of n){const r=getFieldValue(c,"value",t);e.push(r),e.push(...getDescendantValues(c,t))}return e}export function getAncestorValues(o,t,e){return flattenTree(o,e).find(r=>getFieldValue(r,"value",e)===t)?.path.slice(0,-1)||[]}export function filterTree(o,t,e,n="title",c){if(!t)return o;const a=e||((d,u)=>{const s=u[n];return typeof s=="string"?s.toLowerCase().includes(d.toLowerCase()):!1}),f=[];for(const d of o){const u=getFieldValue(d,"children",c),s=u?filterTree(u,t,e,n,c):[];(a(t,d)||s.length>0)&&f.push({...d,children:s.length>0?s:u})}return f}export function useExpandedState(o,t,e,n,c){const[r,a]=x(()=>{if(e){const s=new Set,i=h=>{for(const l of h){const C=getFieldValue(l,"value",c),p=getFieldValue(l,"children",c);p&&p.length>0&&(s.add(C),i(p))}};return i(o),s}return new Set(t||[])}),f=n?new Set(n):r,d=g(s=>{a(i=>{const h=new Set(i);return h.has(s)?h.delete(s):h.add(s),h})},[]),u=g(s=>{a(new Set(s))},[]);return{expandedKeys:f,toggleExpand:d,setExpanded:u}}export function useCheckedState(o,t,e=!1,n){const[c,r]=x(new Set(t||[])),[a,f]=x(new Set);L(()=>{t&&(r(new Set(t)),e||d(new Set(t)))},[t,e]);const d=g(s=>{if(e){f(new Set);return}const i=new Set,h=flattenTree(o,n);for(const l of h){const C=getFieldValue(l,"value",n),p=getFieldValue(l,"children",n);if(p&&p.length>0){const w=getDescendantValues(l,n),S=w.filter(K=>s.has(K));S.length>0&&S.length<w.length&&i.add(C)}}f(i)},[o,e,n]),u=g((s,i)=>{r(h=>{const l=new Set(h);return l.has(s)?(l.delete(s),e||getDescendantValues(i,n).forEach(w=>l.delete(w))):(l.add(s),e||getDescendantValues(i,n).forEach(w=>l.add(w))),e||v(l,s,o,n),d(l),l})},[e,o,n,d]);return{checkedKeys:c,halfCheckedKeys:a,toggleCheck:u,setCheckedKeys:r}}function v(o,t,e,n){const c=getAncestorValues(e,t,n);for(const r of c.reverse()){const a=findNodeByValue(e,r,n);a&&(getDescendantValues(a,n).every(u=>o.has(u))?o.add(r):o.delete(r))}}export function useAsyncLoading(){const[o,t]=x(new Set),[e,n]=x(new Set),c=g((d,u)=>{t(s=>{const i=new Set(s);return u?i.add(d):i.delete(d),i})},[]),r=g(d=>{n(u=>new Set(u).add(d)),t(u=>{const s=new Set(u);return s.delete(d),s})},[]),a=g(d=>o.has(d),[o]),f=g(d=>e.has(d),[e]);return{loadingKeys:o,setLoading:c,markLoaded:r,isLoading:a,isLoaded:f}}
