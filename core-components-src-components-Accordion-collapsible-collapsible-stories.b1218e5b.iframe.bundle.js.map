{"version":3,"file":"core-components-src-components-Accordion-collapsible-collapsible-stories.b1218e5b.iframe.bundle.js","mappings":";;;;;AAcA;;;;;AAOA;AAGA;AACA;;;;AAIA;AAGA;;;;AAOA;AAGA;;;;AAMA;;;;;;;;;AAYA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AAGA;;;AAGA;AACA;;;AAGA;AACA;;AAIA;;;AAGA;;;;;AAKA;AACA;AASA;;;AAOA;;AAEA;AACA;AAoBA;;;;AAQA;AACA;AAOA;;AAEA;;AAGA;AACA;AACA;AAIA;;AAIA;;AAEA;;;;;;;;AAWA;AACA;AAGA;;;;AAMA;;AC/IA;AACA;;AAEA;AACA;;;;;;;AAOA;;;;AAIA;;AASA;;;;;AAOA;;AAEA;;;;AAqBA;;;;AAIA;AAgBA;AA2EA;;;;;;;AC7FA;AACA;AACA;;;AAlEA;;;AAOA;;;AAKA;;;AAKA;;;;AAMA;;;AAKA;AAGA;;AAMA;;AAJA;;;AAFA;;AA6CA;AACA;AAzFA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAmFA;AACA;AAGA;AACA;;;;;AAOA;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;ACzHA;;;;;;;;ACFA;AACA;ACIA;;;;;;;;;;;AAWA;;;;AAMA;AACA;;;AAGA;;;;;;;;;;;;AAgBA;;;;;;;;;AASA;;;;AAIA;;;;AAMA;;;;;AAQA;AACA;;;;;AAKA;;AAIA;;;;;;;;;;;;;AAcA;;AAIA;;;;;;;;AA2BA;;;;AAMA;;;AAIA;AACA;;AAEA;AACA;;;;;AAKA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7HA;;AAKA;AAeA;;;;;;AASA;;AAIA;AAMA","sources":["webpack://react-restyle-components/./src/core-components/src/components/Accordion/AccordionSection/elements.tsx","webpack://react-restyle-components/./src/core-components/src/components/Avatar/Avatar.tsx","webpack://react-restyle-components/./src/core-components/src/components/Badge/InnerBadge/elements.tsx","webpack://react-restyle-components/./src/core-components/src/components/Badge/Badge.tsx","webpack://react-restyle-components/./src/core-components/src/core-components/StateLayer.ts","webpack://react-restyle-components/./src/core-components/src/core-components/ToggleCore/elements.tsx","webpack://react-restyle-components/./src/core-components/src/core-components/SelectionCardStrip/selectionCardStrip.tsx"],"sourcesContent":["import {styled, css} from 'styled-components';\nimport {Icon} from '../../Icon/Icon';\nimport {StateLayer} from '../../../core-components';\n// import {Divider} from '../Divider';\nimport {AccordionVariant, LeadingTrailingAlignment} from './types';\nimport {tokens} from '../../../utils/designTokens';\n\nconst Divider = styled.hr`\n  border: none;\n  border-top: 1px solid;\n  margin: 0;\n  width: 100%;\n`;\n\nexport const AccordionElement = styled.div<{\n  $variant: AccordionVariant | 'inline' | 'full-page';\n}>`\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  flex-direction: column;\n  ${({$variant}) =>\n    $variant === 'inline' &&\n    css`\n      border: 1px solid ${tokens.outline};\n      border-radius: ${tokens.borderRadius100};\n    `};\n  overflow: hidden;\n  width: 100%;\n  color: ${tokens.onSurface};\n`;\n\nexport const AccordionSectionWrapper = styled.div<{\n  $variant: AccordionVariant | 'inline' | 'full-page';\n  $isOpen: boolean;\n}>`\n  overflow: hidden;\n  width: 100%;\n  isolation: isolate;\n  ${({$variant}) =>\n    $variant === 'inline' &&\n    css`\n      &:last-child ${AccordionDivider} {\n        display: none;\n      }\n    `};\n`;\n\nexport const ButtonElement = styled.button<{\n  $variant?: AccordionVariant | 'inline' | 'full-page';\n  $isOpen?: boolean;\n}>`\n  all: unset;\n  box-sizing: border-box;\n\n  z-index: 1;\n  position: relative;\n  cursor: pointer;\n  width: 100%;\n\n  background-color: ${tokens.darkGray || '#4a4a4a'} !important;\n  color: ${tokens.white || '#ffffff'} !important;\n\n  display: flex;\n  gap: ${tokens.spacing100};\n  align-items: center;\n  padding-top: ${tokens.spacing200};\n  padding-right: ${tokens.spacing200};\n  padding-bottom: ${tokens.spacing200};\n  padding-left: ${tokens.spacing200};\n\n  ${({$variant}) =>\n    $variant === 'inline' &&\n    css`\n      border-radius: ${tokens.borderRadius100};\n    `}\n\n  &:hover:not(:disabled) ${StateLayer} {\n    opacity: ${tokens.stateLayerHover};\n  }\n\n  &:active:not(:disabled) ${StateLayer} {\n    opacity: ${tokens.stateLayerPress};\n  }\n`;\n\nexport const AccordionSectionText = styled.div`\n  line-height: 1.3;\n  flex-grow: 1;\n  padding-right: ${tokens.spacing100};\n  position: relative;\n  z-index: 1;\n  display: flex;\n  flex-direction: column;\n  gap: ${tokens.spacing050};\n  color: ${tokens.white};\n`;\n\ntype AccordionSectionContentProps = {\n  $isOpen: boolean;\n  $hasLeader: boolean;\n  $transitionDuration: string;\n};\n\nexport const AccordionFade = styled.div<{\n  $isOpen: boolean;\n  $transitionDuration: string;\n  $transitionTimingFunction: string;\n}>`\n  z-index: 0;\n  position: relative;\n  background: linear-gradient(to bottom, transparent, ${tokens.surface});\n  width: 100%;\n  height: ${tokens.spacing150};\n  margin-top: calc(${tokens.spacing150} * -1);\n`;\n\nconst getTransitionTimingFunction = (\n  transitionTimingFunction: string,\n  isOpen: boolean\n) => {\n  if (\n    transitionTimingFunction !== 'ease-in' &&\n    transitionTimingFunction !== 'ease-out'\n  ) {\n    return transitionTimingFunction;\n  }\n\n  if (isOpen) {\n    return 'ease-out';\n  }\n  return 'ease-in';\n};\n\nexport const AccordionSectionContentWrapper = styled.div<{\n  $isOpen: boolean;\n  $transitionDuration: string;\n  $transitionTimingFunction: string;\n}>`\n  z-index: -1;\n  position: relative;\n  display: grid;\n  grid-template-rows: ${({$isOpen}) => ($isOpen ? '1fr' : '0fr')};\n  transition: ${({$transitionDuration, $transitionTimingFunction, $isOpen}) =>\n    `grid-template-rows ${$transitionDuration} ${getTransitionTimingFunction(\n      $transitionTimingFunction,\n      $isOpen\n    )}`};\n`;\n\nexport const AccordionSectionContent = styled.div<AccordionSectionContentProps>`\n  overflow-y: hidden;\n  transition: ${({$transitionDuration}) =>\n    `opacity ${$transitionDuration} linear`};\n  line-height: 1.3;\n  opacity: ${({$isOpen}) => ($isOpen ? 1 : 0)};\n  padding-right: ${tokens.spacing150};\n  padding-left: ${({$hasLeader}) =>\n    $hasLeader ? tokens.spacing600 : tokens.spacing200};\n`;\n\nexport const StyledLeadingTrailing = styled.div<{\n  alignment?: LeadingTrailingAlignment;\n}>`\n  flex-shrink: 0;\n  min-width: ${tokens.spacing300};\n  display: flex;\n  align-self: ${({alignment}) =>\n    alignment === 'center' ? 'center' : 'flex-start'};\n  position: relative;\n  z-index: 1;\n\n  img,\n  picture {\n    object-fit: contain;\n  }\n`;\n\nexport const AccordionDivider = styled(Divider)`\n  border-color: ${tokens.outline};\n`;\n\nexport const RotatingIcon = styled(Icon.SSR)<{\n  $rotateIcon: boolean;\n}>`\n  overflow: hidden;\n  flex-shrink: 0;\n  transition: transform 0.4s ease-in-out;\n  transform: ${({$rotateIcon}) => `rotate(${$rotateIcon ? -180 : 0}deg)`};\n`;\n","import React from 'react';\nimport {styled} from 'styled-components';\nimport {Icon} from '../Icon/Icon';\n\n// Avatar size configuration\nconst sizeMap = {\n  sm: '2rem', // 32px\n  md: '2.5rem', // 40px\n  lg: '3rem', // 48px\n  xl: '4rem', // 64px\n  xxl: '5rem', // 80px\n} as const;\n\nexport type AvatarSize = keyof typeof sizeMap;\n\nexport interface AvatarProps {\n  /** Full name to extract initials from */\n  name?: string;\n  /** Custom initials (overrides name) */\n  initials?: string;\n  /** Avatar image URL */\n  src?: string;\n  /** Alt text for image */\n  alt?: string;\n  /** Size of the avatar */\n  size?: AvatarSize;\n  /** Background color */\n  backgroundColor?: string;\n  /** Text color */\n  textColor?: string;\n  /** Icon name when no name/image provided */\n  iconName?: string;\n  /** Custom className */\n  className?: string;\n  /** Click handler */\n  onClick?: () => void;\n}\n\n// Styled components\nconst AvatarContainer = styled.div<{\n  $size: AvatarSize;\n  $backgroundColor: string;\n  $textColor: string;\n  $clickable: boolean;\n}>`\n  width: ${({$size}) => sizeMap[$size]};\n  height: ${({$size}) => sizeMap[$size]};\n  border-radius: 50%;\n  background-color: ${({$backgroundColor}) => $backgroundColor};\n  color: ${({$textColor}) => $textColor};\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  position: relative;\n  user-select: none;\n  cursor: ${({$clickable}) => ($clickable ? 'pointer' : 'default')};\n  transition: all 0.2s ease-in-out;\n\n  &:hover {\n    ${({$clickable}) =>\n      $clickable &&\n      `\n      transform: scale(1.05);\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    `}\n  }\n`;\n\nconst AvatarImage = styled.img`\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  border-radius: 50%;\n`;\n\nconst InitialsText = styled.span<{$size: AvatarSize}>`\n  font-weight: 600;\n  font-size: ${({$size}) => {\n    switch ($size) {\n      case 'sm':\n        return '0.75rem'; // 12px\n      case 'md':\n        return '0.875rem'; // 14px\n      case 'lg':\n        return '1rem'; // 16px\n      case 'xl':\n        return '1.25rem'; // 20px\n      case 'xxl':\n        return '1.5rem'; // 24px\n      default:\n        return '0.875rem';\n    }\n  }};\n  line-height: 1;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n`;\n\nconst IconWrapper = styled.div<{$size: AvatarSize}>`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: ${({$size}) => {\n    switch ($size) {\n      case 'sm':\n        return '1rem';\n      case 'md':\n        return '1.25rem';\n      case 'lg':\n        return '1.5rem';\n      case 'xl':\n        return '2rem';\n      case 'xxl':\n        return '2.5rem';\n      default:\n        return '1.25rem';\n    }\n  }};\n  height: ${({$size}) => {\n    switch ($size) {\n      case 'sm':\n        return '1rem';\n      case 'md':\n        return '1.25rem';\n      case 'lg':\n        return '1.5rem';\n      case 'xl':\n        return '2rem';\n      case 'xxl':\n        return '2.5rem';\n      default:\n        return '1.25rem';\n    }\n  }};\n`;\n\n// Utility functions\nconst getInitials = (name: string): string => {\n  if (!name) return '';\n\n  const nameParts = name.trim().split(/\\s+/);\n\n  if (nameParts.length === 1) {\n    return nameParts[0].charAt(0).toUpperCase();\n  }\n\n  // Take first letter of first name and first letter of last name\n  const firstInitial = nameParts[0].charAt(0).toUpperCase();\n  const lastInitial = nameParts[nameParts.length - 1].charAt(0).toUpperCase();\n\n  return firstInitial + lastInitial;\n};\n\nconst generateBackgroundColor = (text: string): string => {\n  // Generate a consistent color based on text\n  const colors = [\n    '#f56565',\n    '#ed8936',\n    '#ecc94b',\n    '#48bb78',\n    '#38b2ac',\n    '#4299e1',\n    '#667eea',\n    '#9f7aea',\n    '#ed64a6',\n    '#f687b3',\n    '#fc8181',\n    '#f6ad55',\n    '#fbd38d',\n    '#68d391',\n    '#4fd1c7',\n    '#63b3ed',\n    '#7c3aed',\n    '#a78bfa',\n    '#f093fb',\n    '#fbb6ce',\n  ];\n\n  let hash = 0;\n  for (let i = 0; i < text.length; i++) {\n    hash = text.charCodeAt(i) + ((hash << 5) - hash);\n  }\n\n  return colors[Math.abs(hash) % colors.length];\n};\n\nconst getContrastColor = (backgroundColor: string): string => {\n  // Simple contrast calculation\n  const darkColors = ['#f56565', '#ed8936', '#667eea', '#9f7aea', '#7c3aed'];\n  return darkColors.includes(backgroundColor) ? '#ffffff' : '#ffffff';\n};\n\n// Main Avatar component\nexport const Avatar: React.FC<AvatarProps> = ({\n  name = '',\n  initials,\n  src,\n  alt,\n  size = 'md',\n  backgroundColor,\n  textColor,\n  iconName = 'FaUser',\n  className,\n  onClick,\n}) => {\n  // Determine what to display\n  const displayInitials = initials || getInitials(name);\n  const defaultBgColor =\n    backgroundColor ||\n    generateBackgroundColor(displayInitials || name || 'User');\n  const defaultTextColor = textColor || getContrastColor(defaultBgColor);\n\n  // Render image if src is provided\n  if (src) {\n    return (\n      <AvatarContainer\n        $size={size}\n        $backgroundColor={defaultBgColor}\n        $textColor={defaultTextColor}\n        $clickable={!!onClick}\n        className={className}\n        onClick={onClick}\n        title={name || alt}\n      >\n        <AvatarImage src={src} alt={alt || name || 'Avatar'} />\n      </AvatarContainer>\n    );\n  }\n\n  // Render initials if name or initials are provided\n  if (displayInitials) {\n    return (\n      <AvatarContainer\n        $size={size}\n        $backgroundColor={defaultBgColor}\n        $textColor={defaultTextColor}\n        $clickable={!!onClick}\n        className={className}\n        onClick={onClick}\n        title={name || `${displayInitials} Avatar`}\n      >\n        <InitialsText $size={size}>{displayInitials}</InitialsText>\n      </AvatarContainer>\n    );\n  }\n\n  // Render icon as fallback\n  return (\n    <AvatarContainer\n      $size={size}\n      $backgroundColor={defaultBgColor}\n      $textColor={defaultTextColor}\n      $clickable={!!onClick}\n      className={className}\n      onClick={onClick}\n      title=\"User Avatar\"\n    >\n      <IconWrapper $size={size}>\n        <Icon\n          nameIcon={iconName}\n          propsIcon={{\n            color: defaultTextColor,\n            size: '100%',\n          }}\n        />\n      </IconWrapper>\n    </AvatarContainer>\n  );\n};\n\n// Export size constants for external use\nexport const AVATAR_SIZES = Object.keys(sizeMap) as AvatarSize[];\n\n// Default export\nexport default Avatar;\n","import {styled, css} from 'styled-components';\nimport {Icon} from '../../Icon/Icon';\nimport {\n  BadgeOverlap,\n  BadgePosition,\n  BadgeSize,\n  BadgeVariant,\n  sizeMap,\n} from '../types';\n\nconst getTransform = (overlap: BadgeOverlap, position: BadgePosition) => {\n  const [vertical, horizontal] = position.split('-');\n\n  let verticalTranslate: string, horizontalTranslate: string;\n\n  vertical === 'top'\n    ? (verticalTranslate = '-50%')\n    : (verticalTranslate = '50%');\n\n  horizontal === 'right'\n    ? (horizontalTranslate = '50%')\n    : (horizontalTranslate = '-50%');\n\n  if (overlap === 'square') {\n    return css`\n      transform: translate(${horizontalTranslate}, ${verticalTranslate});\n      ${vertical}: 0;\n      ${horizontal}: 0;\n    `;\n  }\n  return css`\n    transform: translate(${horizontalTranslate}, ${verticalTranslate});\n    ${vertical}: 14%;\n    ${horizontal}: 14%;\n  `;\n};\n\nconst getColor = (variant: BadgeVariant) => {\n  switch (variant) {\n    case 'alert':\n      return css`\n        background-color: var(--aui-status-error);\n        color: var(--aui-status-on-error);\n      `;\n    case 'warn':\n      return css`\n        background-color: var(--aui-status-warning);\n        color: var(--aui-status-on-warning);\n      `;\n    case 'positive':\n      return css`\n        background-color: var(--aui-status-success);\n        color: var(--aui-status-on-success);\n      `;\n    case 'neutral':\n      return css`\n        background-color: var(--aui-neutral-soft);\n        color: var(--aui-on-neutral-soft);\n        border: 1px solid var(--aui-outline);\n      `;\n    default:\n      return css`\n        background-color: var(--aui-primary);\n        color: var(--aui-on-primary);\n      `;\n  }\n};\n\nconst getPadding = (size: BadgeSize, hasIcon: boolean) => {\n  if (size === 'sm' && !hasIcon) {\n    return css`\n      padding: 0 var(--aui-spacing-050);\n    `;\n  } else if (size === 'md' && !hasIcon) {\n    return css`\n      padding: 0 var(--aui-spacing-075);\n    `;\n  } else {\n    return css`\n      padding: 0;\n    `;\n  }\n};\n\ntype StyledBadgeProps = {\n  $overlap: BadgeOverlap;\n  $size: BadgeSize;\n  $position: BadgePosition;\n  $variant: BadgeVariant;\n  $hasIcon: boolean;\n};\n\ntype StyledInlineProps = Omit<StyledBadgeProps, '$overlap' | '$position'>;\n\nconst getSharedStyles = (props: StyledInlineProps) => css`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  border-radius: 1rem;\n  width: fit-content;\n  min-height: ${sizeMap[props.$size]};\n  min-width: ${sizeMap[props.$size]};\n  ${props.$size === 'hint' &&\n  css`\n    outline: 2px solid var(--aui-surface);\n  `}\n  ${getColor(props.$variant)};\n  ${getPadding(props.$size, props.$hasIcon)}\n`;\n\nexport const StyledBadge = styled.div<StyledBadgeProps>`\n  position: absolute;\n  ${getSharedStyles}\n  ${(props) => getTransform(props.$overlap, props.$position)};\n`;\n\nexport const StyledInline = styled.div<StyledInlineProps>`\n  ${getSharedStyles}\n`;\n\nexport const StyledText = styled.span<{$size: BadgeSize}>`\n  font-size: ${({$size}) => ($size === 'sm' ? '0.75rem' : '0.875rem')};\n  font-weight: 700;\n  line-height: 1rem;\n  vertical-align: middle;\n  font-variant-numeric: tabular-nums lining-nums;\n`;\n\nexport const StyledIcon = styled.div<{$size: BadgeSize}>`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: ${({$size}) => ($size === 'sm' ? '0.625rem' : '0.75rem')};\n  height: ${({$size}) => ($size === 'sm' ? '0.625rem' : '0.75rem')};\n\n  .iconContainer {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n\n  .icon {\n    width: 100%;\n    height: 100%;\n  }\n`;\n","import React, {memo, useMemo} from 'react';\nimport {attachSubComponents} from '../../utils';\nimport {BadgeProps} from './types';\nimport {InnerBadge} from './InnerBadge/InnerBadge';\nimport {styled} from 'styled-components';\nimport {InlineBadge} from './InnerBadge/Inline';\n\nconst BadgeContainer = styled.div`\n  position: relative;\n  width: min-content;\n  display: inline-block;\n`;\n\nconst BadgeComponent = React.forwardRef<HTMLDivElement, BadgeProps>(\n  (\n    {\n      size = 'hint',\n      overlap = 'circular',\n      children,\n      position = 'bottom-right',\n      variant = 'notification',\n      iconSrc,\n      count,\n      'aria-label': ariaLabel,\n      ...props\n    },\n    ref\n  ) => {\n    // Generate accessible label for the badge\n    const badgeAriaLabel = useMemo(() => {\n      if (ariaLabel) return ariaLabel;\n      if (typeof count === 'number') return `${count} notifications`;\n      if (typeof count === 'string' && count) return `${count} notifications`;\n      return undefined;\n    }, [ariaLabel, count]);\n\n    return (\n      <BadgeContainer ref={ref} data-aui=\"badge\" {...props}>\n        <InnerBadge\n          position={position}\n          size={size}\n          overlap={overlap}\n          variant={variant}\n          iconSrc={iconSrc}\n          count={count}\n          aria-label={badgeAriaLabel}\n        />\n        {children}\n      </BadgeContainer>\n    );\n  }\n);\n\nBadgeComponent.displayName = 'Badge';\n\nexport const Badge = attachSubComponents('Badge', memo(BadgeComponent), {\n  Inline: InlineBadge,\n});\n","import {styled} from 'styled-components';\nimport {tokens} from '../utils/designTokens';\n\nexport const StateLayer = styled.div`\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  z-index: 0;\n  background: ${tokens.darkGray || '#4a4a4a'} !important;\n  opacity: ${tokens.stateLayerNone};\n`;\n","import React from 'react';\nimport {styled, css} from 'styled-components';\nimport {createTransition} from '../../utils';\nimport {StateLayer} from '../StateLayer';\n// import {Text} from '../../components/Text';\n\nconst Text = (props: any) => {\n  return <span {...props} />;\n};\n\ntype ToggleProps = {\n  $checked: boolean;\n  $showInteraction: boolean;\n  $indeterminate?: boolean;\n};\n\nconst baseToggleStyles = css<ToggleProps>`\n  position: relative;\n  display: block;\n  box-sizing: border-box;\n  overflow: hidden;\n\n  width: 1.25rem;\n  height: 1.25rem;\n  flex-shrink: 0;\n  margin-right: var(--aui-spacing-100);\n\n  ${({$showInteraction}) =>\n    $showInteraction &&\n    css`\n      // Transitions\n      &:before,\n      [data-aui='icon'],\n      ${StateLayer} {\n        ${createTransition({properties: ['opacity']})}\n      }\n\n      ${createTransition({\n        properties: ['box-shadow', 'background-color', 'color'],\n      })}\n\n      // Support keyboard focus\n      &:has(~ input:focus-visible) {\n        outline: 1px solid blue;\n      }\n\n      // Disabled styles\n      &:has(~ input:disabled) {\n        opacity: var(--aui-state-layer-on-disabled);\n      }\n    `}\n`;\n\nconst StyledCheckbox = styled.span<ToggleProps>`\n  [data-aui='icon-check'],\n  [data-aui='icon-minus'] {\n    position: absolute;\n    inset: 0;\n    margin: auto;\n    transition: opacity 0.15s;\n    pointer-events: none;\n  }\n  ${baseToggleStyles};\n\n  border-radius: var(--aui-border-radius-050);\n\n  ${({$checked, $indeterminate}) =>\n    $checked || $indeterminate\n      ? css`\n          box-shadow: 0 0 0 1px var(--aui-inverse-surface) inset;\n          background: var(--aui-inverse-surface);\n          color: var(--aui-inverse-on-surface);\n        `\n      : css`\n          box-shadow: 0 0 0 1px var(--aui-outline) inset;\n          background: var(--aui-surface);\n          color: var(--aui-on-surface);\n        `}\n`;\n\nconst StyledRadio = styled.span<ToggleProps>`\n  ${baseToggleStyles};\n\n  border-radius: var(--aui-border-radius-round);\n  background: var(--aui-surface);\n\n  ${({$checked}) =>\n    $checked\n      ? css`\n          box-shadow: 0 0 0 2px var(--aui-inverse-surface) inset;\n        `\n      : css`\n          box-shadow: 0 0 0 1px var(--aui-outline) inset;\n        `}\n\n  &:before {\n    content: '';\n    position: absolute;\n    border-radius: var(--aui-border-radius-round);\n    width: 0.625rem;\n    height: 0.625rem;\n    top: 0.3125rem;\n    left: 0.3125rem;\n    background: var(--aui-inverse-surface);\n    opacity: ${({$checked}) => ($checked ? '1' : '0')};\n  }\n`;\n\nexport const CheckboxToggle = ({...props}: ToggleProps) => (\n  <StyledCheckbox {...props}>\n    <StateLayer />\n    {/* <Icon nameIcon=\"IoIosCheckmarkCircleOutline\" />\n    <Icon nameIcon=\"FaMinusCircle\" /> */}\n    <span>Icons</span>\n  </StyledCheckbox>\n);\n\nexport const RadioToggle = (props: ToggleProps) => (\n  <StyledRadio {...props}>\n    <StateLayer />\n  </StyledRadio>\n);\n\nexport const StyledDescription = styled(Text).attrs({\n  size: 2,\n})`\n  color: var(--aui-on-surface);\n  line-height: 1.3;\n\n  &:has(~ input:disabled) {\n    opacity: var(--aui-state-layer-on-disabled);\n    cursor: not-allowed;\n  }\n`;\n\nexport const HiddenInput = styled.input`\n  position: fixed;\n  opacity: 0;\n  pointer-events: none;\n`;\n\n/** Add this style snippet to the label containing this ToggleCore component */\nexport const toggleParentStyles = css`\n  &:not(:has(input:disabled)) {\n    &:hover\n      ${StyledCheckbox}\n      ${StateLayer},\n      &:hover\n      ${StyledRadio}\n      ${StateLayer} {\n      opacity: var(--aui-state-layer-hover);\n    }\n\n    &:active\n      ${StyledCheckbox}\n      ${StateLayer},\n      &:hover\n      ${StyledRadio}\n      ${StateLayer} {\n      opacity: var(--aui-state-layer-press);\n    }\n  }\n`;\n","'use client';\n\nimport React, {HTMLAttributes} from 'react';\nimport {styled} from 'styled-components';\n// import {Card, CardProps} from '../../components/Card';\nimport {createTransition, dontForwardProps} from '../../utils';\nimport {colors} from '../../utils';\nimport {toggleParentStyles} from '../ToggleCore';\n\nconst Card = (props: any) => {\n  return <div {...props} />;\n};\n\nexport type CardProps = {\n  selected?: boolean;\n  type?: 'selection' | 'default';\n  element?: string;\n};\n\ntype WrapperProps = HTMLAttributes<HTMLElement> &\n  CardProps & {\n    checked?: boolean;\n    focused?: boolean;\n  };\n\nconst StyledCard = styled(Card).withConfig(dontForwardProps())<WrapperProps>`\n  display: inline-flex;\n  align-items: flex-start;\n  box-sizing: border-box;\n  text-align: left;\n  line-height: 1.3;\n  -moz-osx-font-smoothing: grayscale;\n\n  ${() =>\n    createTransition({\n      properties: ['box-shadow', 'background-color'],\n    })}\n\n  ${toggleParentStyles};\n`;\n\nconst Wrapper = React.forwardRef<HTMLDivElement, WrapperProps>(\n  (props, fRef) => (\n    <StyledCard\n      ref={fRef}\n      element=\"label\"\n      type=\"selection\"\n      selected={props.checked || props.focused}\n      {...props}\n    />\n  )\n);\n\nconst InternalWrapper = styled.div.withConfig(dontForwardProps())<{\n  isDisabled: boolean;\n  disableSvgColorOverride?: boolean;\n}>`\n  display: flex;\n  z-index: 1;\n  width: 100%;\n  justify-content: center;\n  padding: 0.1rem 0 0 0;\n  ${createTransition({\n    properties: ['color'],\n  })};\n\n  ${({isDisabled}) =>\n    isDisabled &&\n    `\n      cursor: not-allowed;\n      color: ${colors.disabledText};\n`}\n  ${({disableSvgColorOverride, isDisabled}) =>\n    !disableSvgColorOverride &&\n    `\n    svg path {\n      fill: none;\n      stroke: ${isDisabled && colors.disabledText};\n    }\n`}\n`;\n\nexport const SelectionCardStrip = {\n  Wrapper,\n  InternalWrapper,\n};\n"],"names":[],"sourceRoot":""}